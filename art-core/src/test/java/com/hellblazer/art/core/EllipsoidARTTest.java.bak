/*
 * Copyright (c) 2025 Hal Hildebrand. All rights reserved.
 * 
 * This file is part of Java ART Neural Networks.
 * 
 * Java ART Neural Networks is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Java ART Neural Networks is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with Java ART Neural Networks. If not, see <https://www.gnu.org/licenses/>.
 */
package com.hellblazer.art.core;

import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * Comprehensive test suite for EllipsoidART implementation.
 * Written BEFORE any EllipsoidART implementation exists.
 * These tests define the complete specification and expected behavior.
 * 
 * EllipsoidART uses ellipsoidal category regions with Mahalanobis distance
 * instead of simple geometric shapes for more flexible category boundaries.
 * 
 * @author Hal Hildebrand
 */
class EllipsoidARTTest {
    
    private static final double TOLERANCE = 1e-6;
    private static final double LOOSE_TOLERANCE = 1e-3;
    private static final int DEFAULT_MAX_CATEGORIES = 100;
    
    private EllipsoidART createDefaultART() {
        var params = new EllipsoidParameters(
            0.7,                    // vigilance 
            0.1,                    // learningRate
            2,                      // dimensions
            0.01,                   // minVariance (regularization)
            10.0,                   // maxVariance (prevents explosion)
            1.5,                    // shapeAdaptationRate
            DEFAULT_MAX_CATEGORIES  // maxCategories
        );
        return new EllipsoidART(params);
    }
    
    private EllipsoidART createCustomART(double vigilance, double learningRate, double minVariance) {
        var params = new EllipsoidParameters(
            vigilance, learningRate, 2, minVariance, 10.0, 1.5, DEFAULT_MAX_CATEGORIES
        );
        return new EllipsoidART(params);
    }
    
    @Nested
    @DisplayName("Constructor and Parameter Tests")
    class ConstructorTests {
        
        @Test
        @DisplayName("Should create EllipsoidART with valid parameters")
        void shouldCreateWithValidParameters() {
            var params = new EllipsoidParameters(0.8, 0.1, 3, 0.01, 5.0, 1.2, 50);
            
            assertThatCode(() -> new EllipsoidART(params))
                .doesNotThrowAnyException();
            
            var art = new EllipsoidART(params);
            assertThat(art.getVigilance()).isCloseTo(0.8, within(TOLERANCE));
            assertThat(art.getLearningRate()).isCloseTo(0.1, within(TOLERANCE));
            assertThat(art.getDimensions()).isEqualTo(3);
            assertThat(art.getCategoryCount()).isEqualTo(0);
            assertThat(art.is_fitted()).isFalse();
        }
        
        @ParameterizedTest
        @ValueSource(doubles = {-0.1, 1.1, Double.NaN, Double.POSITIVE_INFINITY})
        @DisplayName("Should reject invalid vigilance parameters")
        void shouldRejectInvalidVigilance(double invalidVigilance) {
            assertThatThrownBy(() -> {
                var params = new EllipsoidParameters(invalidVigilance, 0.1, 2, 0.01, 5.0, 1.0, 100);
                new EllipsoidART(params);
            }).isInstanceOf(IllegalArgumentException.class)
              .hasMessageContaining("vigilance");
        }
        
        @ParameterizedTest
        @ValueSource(doubles = {-0.1, 1.1, Double.NaN})
        @DisplayName("Should reject invalid learning rate parameters")
        void shouldRejectInvalidLearningRate(double invalidLearningRate) {
            assertThatThrownBy(() -> {
                var params = new EllipsoidParameters(0.7, invalidLearningRate, 2, 0.01, 5.0, 1.0, 100);
                new EllipsoidART(params);
            }).isInstanceOf(IllegalArgumentException.class)
              .hasMessageContaining("learning");
        }
        
        @ParameterizedTest
        @ValueSource(ints = {0, -1, -10})
        @DisplayName("Should reject invalid dimensions")
        void shouldRejectInvalidDimensions(int invalidDimensions) {
            assertThatThrownBy(() -> {
                var params = new EllipsoidParameters(0.7, 0.1, invalidDimensions, 0.01, 5.0, 1.0, 100);
                new EllipsoidART(params);
            }).isInstanceOf(IllegalArgumentException.class)
              .hasMessageContaining("dimensions");
        }
        
        @Test
        @DisplayName("Should reject minVariance >= maxVariance")
        void shouldRejectInvalidVarianceRange() {
            assertThatThrownBy(() -> {
                var params = new EllipsoidParameters(0.7, 0.1, 2, 5.0, 5.0, 1.0, 100); // min == max
                new EllipsoidART(params);
            }).isInstanceOf(IllegalArgumentException.class)
              .hasMessageContaining("minVariance must be less than maxVariance");
        }
        
        @ParameterizedTest
        @ValueSource(doubles = {0.0, -0.1, Double.NaN})
        @DisplayName("Should reject invalid shape adaptation rates")
        void shouldRejectInvalidShapeAdaptationRate(double invalidRate) {
            assertThatThrownBy(() -> {
                var params = new EllipsoidParameters(0.7, 0.1, 2, 0.01, 5.0, invalidRate, 100);
                new EllipsoidART(params);
            }).isInstanceOf(IllegalArgumentException.class)
              .hasMessageContaining("shape");
        }
    }
    
    @Nested
    @DisplayName("Mathematical Correctness Tests")
    class MathematicalCorrectness {
        
        @Test
        @DisplayName("Should calculate Mahalanobis distance correctly")
        void shouldCalculateMahalanobisDistance() {
            var art = createDefaultART();
            
            // Known ellipsoid parameters
            var center = new DenseVector(new double[]{0.5, 0.3});
            var covariance = new Matrix(new double[][]{{0.1, 0.02}, {0.02, 0.15}});
            var weight = new EllipsoidWeight(center, covariance, 10);
            
            // Test point
            var input = new DenseVector(new double[]{0.52, 0.28});
            
            // Calculate Mahalanobis distance
            var distance = art.calculateMahalanobisDistance(input, weight);
            
            // Hand-calculated expected result
            var diff = new double[]{0.02, -0.02}; // input - center
            var expectedDistance = calculateExpectedMahalanobisDistance(diff, covariance);
            
            assertThat(distance)
                .as("Mahalanobis distance should match mathematical expectation")
                .isCloseTo(expectedDistance, within(TOLERANCE));
        }
        
        @Test
        @DisplayName("Should perform correct ellipsoid shape adaptation")
        void shouldPerformCorrectShapeAdaptation() {
            var art = createDefaultART();
            
            // Initial ellipsoid
            var center = new DenseVector(new double[]{0.0, 0.0});
            var initialCov = Matrix.eye(2).multiply(0.1);
            var initialWeight = new EllipsoidWeight(center, initialCov, 1);
            
            // New observation that should stretch the ellipsoid
            var observation = new DenseVector(new double[]{0.3, 0.1});
            var params = new EllipsoidParameters(0.7, 0.5, 2, 0.01, 10.0, 1.5, 100);
            
            // Update ellipsoid shape
            var updatedWeight = art.updateEllipsoidShape(initialWeight, observation, params);
            
            // Verify shape adaptation
            assertThat(updatedWeight.center().get(0))
                .as("Center should move toward observation")
                .isGreaterThan(center.get(0));
            
            assertThat(updatedWeight.covariance().get(0, 0))
                .as("Covariance should adapt to accommodate new point")
                .isGreaterThan(initialCov.get(0, 0));
            
            assertThat(updatedWeight.sampleCount())
                .as("Sample count should increment")
                .isEqualTo(2);
        }
        
        @Test
        @DisplayName("Should maintain ellipsoid volume constraints")
        void shouldMaintainVolumeConstraints() {
            var art = createCustomART(0.7, 0.1, 0.01);
            
            // Create ellipsoid that might violate volume constraints
            var center = new DenseVector(new double[]{0.5, 0.5});
            var largeCov = Matrix.eye(2).multiply(15.0); // Exceeds maxVariance
            var weight = new EllipsoidWeight(center, largeCov, 5);
            
            // Apply volume constraints
            var constrainedWeight = art.applyVolumeConstraints(weight);
            
            // Verify constraints are enforced
            for (int i = 0; i < 2; i++) {
                assertThat(constrainedWeight.covariance().get(i, i))
                    .as("Diagonal covariance elements should be within bounds")
                    .isBetween(0.01, 10.0);
            }
        }
        
        @Test
        @DisplayName("Should handle numerical stability with ill-conditioned ellipsoids")
        void shouldHandleNumericalStability() {
            var art = createCustomART(0.7, 0.1, 1e-6);
            
            // Create nearly singular covariance matrix
            var center = new DenseVector(new double[]{0.0, 0.0});
            var illConditioned = new Matrix(new double[][]{{1e-8, 0.9e-8}, {0.9e-8, 1e-8}});
            var weight = new EllipsoidWeight(center, illConditioned, 1);
            
            var testPoint = new DenseVector(new double[]{1e-7, 1e-7});
            
            // Should not throw numerical exceptions
            assertThatCode(() -> {
                art.calculateMahalanobisDistance(testPoint, weight);
            }).doesNotThrowAnyException();
            
            var distance = art.calculateMahalanobisDistance(testPoint, weight);
            assertThat(distance)
                .as("Distance should be finite and positive")
                .isFinite()
                .isPositive();
        }
    }
    
    @Nested
    @DisplayName("Ellipsoid-Specific Functionality Tests")
    class EllipsoidSpecificTests {
        
        @Test
        @DisplayName("Should adapt ellipsoid shape based on data distribution")
        void shouldAdaptEllipsoidShape() {
            var art = createDefaultART();
            
            // Train with elongated cluster
            var elongatedData = new Pattern[]{
                new DenseVector(new double[]{0.1, 0.05}),
                new DenseVector(new double[]{0.2, 0.10}),
                new DenseVector(new double[]{0.3, 0.15}),
                new DenseVector(new double[]{0.4, 0.20}),
                new DenseVector(new double[]{0.5, 0.25})
            };
            
            art.fit(elongatedData);
            
            assertThat(art.getCategoryCount()).isEqualTo(1);
            
            var weight = art.getEllipsoidWeight(0);
            var cov = weight.covariance();
            
            // Should have larger variance in direction of elongation
            assertThat(cov.get(0, 0))
                .as("Variance in x-direction should be larger")
                .isGreaterThan(cov.get(1, 1));
            
            // Should capture correlation between dimensions
            assertThat(Math.abs(cov.get(0, 1)))
                .as("Should have positive correlation")
                .isGreaterThan(0.001);
        }
        
        @Test
        @DisplayName("Should provide ellipsoid-specific activation results")
        void shouldProvideEllipsoidSpecificActivationResults() {
            var art = createDefaultART();
            var trainingData = new Pattern[]{
                new DenseVector(new double[]{0.1, 0.1}),
                new DenseVector(new double[]{0.9, 0.9})
            };
            
            art.fit(trainingData);
            
            var testPoint = new DenseVector(new double[]{0.12, 0.08});
            var result = art.predict(testPoint);
            
            assertThat(result).isInstanceOf(EllipsoidActivationResult.class);
            
            var ellipsoidResult = (EllipsoidActivationResult) result;
            assertThat(ellipsoidResult.mahalanobisDistance())
                .as("Should provide Mahalanobis distance")
                .isFinite()
                .isPositive();
            
            assertThat(ellipsoidResult.ellipsoidVolume())
                .as("Should provide ellipsoid volume")
                .isFinite()
                .isPositive();
            
            assertThat(ellipsoidResult.confidenceEllipse())
                .as("Should provide confidence ellipse parameters")
                .isNotNull();
        }
        
        @Test
        @DisplayName("Should handle different ellipsoid orientations")
        void shouldHandleDifferentOrientations() {
            var art = createDefaultART();
            
            // Create data with different orientations
            var diagonal1 = new Pattern[]{
                new DenseVector(new double[]{0.1, 0.1}),
                new DenseVector(new double[]{0.2, 0.2}),
                new DenseVector(new double[]{0.3, 0.3})
            };
            
            var diagonal2 = new Pattern[]{
                new DenseVector(new double[]{0.1, 0.9}),
                new DenseVector(new double[]{0.2, 0.8}),
                new DenseVector(new double[]{0.3, 0.7})
            };
            
            var allData = new Pattern[diagonal1.length + diagonal2.length];
            System.arraycopy(diagonal1, 0, allData, 0, diagonal1.length);
            System.arraycopy(diagonal2, 0, allData, diagonal1.length, diagonal2.length);
            
            art.fit(allData);
            
            // Should create separate ellipsoids for different orientations
            assertThat(art.getCategoryCount())
                .as("Should recognize distinct orientations as separate categories")
                .isGreaterThanOrEqualTo(2);
        }
        
        @Test
        @DisplayName("Should compute ellipsoid intersection probabilities")
        void shouldComputeIntersectionProbabilities() {
            var art = createDefaultART();
            
            // Create overlapping ellipsoids
            var center1 = new DenseVector(new double[]{0.3, 0.3});
            var center2 = new DenseVector(new double[]{0.7, 0.7});
            var cov = Matrix.eye(2).multiply(0.1);
            
            var weight1 = new EllipsoidWeight(center1, cov, 5);
            var weight2 = new EllipsoidWeight(center2, cov, 5);
            
            // Point between ellipsoids
            var testPoint = new DenseVector(new double[]{0.5, 0.5});
            
            var intersection = art.calculateEllipsoidIntersection(weight1, weight2);
            var prob1 = art.calculateMembershipProbability(testPoint, weight1);
            var prob2 = art.calculateMembershipProbability(testPoint, weight2);
            
            assertThat(intersection)
                .as("Should detect ellipsoid intersection")
                .isPositive();
            
            assertThat(prob1 + prob2)
                .as("Membership probabilities should be meaningful")
                .isGreaterThan(0.0);
        }
    }
    
    @Nested
    @DisplayName("Scikit-learn Compatibility Tests")
    class ScikitLearnCompatibility {
        
        @Test
        @DisplayName("Should implement complete ScikitClusterer interface")
        void shouldImplementScikitClustererInterface() {
            var art = createDefaultART();
            
            assertThat(art).isInstanceOf(ScikitClusterer.class);
            
            var X_train = new double[][]{
                {0.1, 0.2}, {0.15, 0.25}, {0.12, 0.18},
                {0.7, 0.8}, {0.72, 0.85}, {0.68, 0.75}
            };
            
            // Test fit methods
            var fittedART = art.fit(X_train);
            assertThat(fittedART).isSameAs(art);
            assertThat(art.is_fitted()).isTrue();
            
            // Test prediction methods
            var predictions = art.predict(X_train);
            assertThat(predictions).hasSize(6);
            
            var probabilities = art.predict_proba(X_train);
            assertThat(probabilities).hasSize(6);
            
            // Test cluster centers
            var centers = art.cluster_centers();
            assertThat(centers).hasSizeGreaterThan(0);
        }
        
        @Test
        @DisplayName("Should provide clustering metrics with ellipsoid-specific measures")
        void shouldProvideEllipsoidSpecificMetrics() {
            var art = createDefaultART();
            var X = generateTestData(100, 3); // 100 points, 3 natural clusters
            
            art.fit(X);
            var labels = art.predict(X);
            var metrics = art.clustering_metrics(X, labels);
            
            // Standard clustering metrics
            assertThat(metrics).containsKeys(
                "silhouette_score", "calinski_harabasz_score", "davies_bouldin_score",
                "inertia", "n_clusters"
            );
            
            // Ellipsoid-specific metrics
            assertThat(metrics).containsKeys(
                "average_ellipsoid_volume", "shape_regularity_score", 
                "orientation_diversity", "volume_ratio_variance"
            );
            
            assertThat(metrics.get("average_ellipsoid_volume"))
                .as("Should provide meaningful ellipsoid volume")
                .isPositive();
            
            assertThat(metrics.get("shape_regularity_score"))
                .as("Should measure ellipsoid shape regularity")
                .isBetween(0.0, 1.0);
        }
        
        @Test
        @DisplayName("Should support parameter getting and setting")
        void shouldSupportParameterOperations() {
            var art = createDefaultART();
            var originalParams = art.get_params();
            
            assertThat(originalParams).containsKeys(
                "vigilance", "learningRate", "dimensions", 
                "minVariance", "maxVariance", "shapeAdaptationRate"
            );
            
            // Test parameter modification
            var newParams = new HashMap<>(originalParams);
            newParams.put("vigilance", 0.85);
            newParams.put("learningRate", 0.05);
            
            var modifiedART = art.set_params(newParams);
            assertThat(modifiedART).isSameAs(art);
            
            var updatedParams = art.get_params();
            assertThat((Double) updatedParams.get("vigilance"))
                .isCloseTo(0.85, within(TOLERANCE));
            assertThat((Double) updatedParams.get("learningRate"))
                .isCloseTo(0.05, within(TOLERANCE));
        }
    }
    
    @Nested
    @DisplayName("Performance and Scalability Tests")
    @Timeout(value = 10, unit = TimeUnit.SECONDS)
    class PerformanceTests {
        
        @Test
        @DisplayName("Should handle large datasets efficiently")
        void shouldHandleLargeDatasets() {
            var art = createDefaultART();
            var largeDataset = generateTestData(2000, 5); // 2K points, 5D
            
            var startTime = System.nanoTime();
            art.fit(largeDataset);
            var fitTime = System.nanoTime() - startTime;
            
            startTime = System.nanoTime();
            var predictions = art.predict(generateTestData(500, 5));
            var predictTime = System.nanoTime() - startTime;
            
            // Performance expectations
            assertThat(fitTime)
                .as("Fitting should complete within reasonable time")
                .isLessThan(5_000_000_000L); // 5 seconds
            
            assertThat(predictTime)
                .as("Prediction should be fast")
                .isLessThan(500_000_000L); // 0.5 seconds
            
            assertThat(predictions).hasSize(500);
        }
        
        @Test
        @DisplayName("Should maintain reasonable memory usage")
        void shouldMaintainReasonableMemoryUsage() {
            var art = createDefaultART();
            var runtime = Runtime.getRuntime();
            
            var memoryBefore = runtime.totalMemory() - runtime.freeMemory();
            
            // Train on moderately sized dataset
            var dataset = generateTestData(1000, 10);
            art.fit(dataset);
            
            var memoryAfter = runtime.totalMemory() - runtime.freeMemory();
            var memoryGrowth = memoryAfter - memoryBefore;
            
            // Memory growth should be reasonable (less than 50MB for this dataset)
            assertThat(memoryGrowth)
                .as("Memory growth should be controlled")
                .isLessThan(50_000_000);
        }
        
        @Test
        @DisplayName("Should scale appropriately with dimensionality")
        void shouldScaleWithDimensionality() {
            var dimensions = List.of(2, 5, 10, 15);
            var results = new HashMap<Integer, Long>();
            
            for (var d : dimensions) {
                var params = new EllipsoidParameters(0.7, 0.1, d, 0.01, 5.0, 1.0, 50);
                var art = new EllipsoidART(params);
                var data = generateTestData(500, d);
                
                var startTime = System.nanoTime();
                art.fit(data);
                var endTime = System.nanoTime();
                
                results.put(d, endTime - startTime);
            }
            
            // Should not have exponential scaling
            var time2D = results.get(2);
            var time15D = results.get(15);
            var scalingFactor = (double) time15D / time2D;
            
            // Should be better than O(d^3) scaling
            assertThat(scalingFactor)
                .as("Scaling should be sub-cubic")
                .isLessThan(Math.pow(15.0/2.0, 3));
        }
    }
    
    @Nested
    @DisplayName("Error Handling and Edge Cases")
    class ErrorHandlingTests {
        
        @Test
        @DisplayName("Should handle empty training data")
        void shouldHandleEmptyTrainingData() {
            var art = createDefaultART();
            var emptyData = new Pattern[0];
            
            assertThatThrownBy(() -> art.fit(emptyData))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("empty");
        }
        
        @Test
        @DisplayName("Should handle prediction before fitting")
        void shouldHandlePredictionBeforeFitting() {
            var art = createDefaultART();
            var testInput = new DenseVector(new double[]{0.5, 0.5});
            
            assertThatThrownBy(() -> art.predict(testInput))
                .isInstanceOf(IllegalStateException.class)
                .hasMessageContaining("not fitted");
        }
        
        @Test
        @DisplayName("Should handle inconsistent input dimensions")
        void shouldHandleInconsistentInputDimensions() {
            var art = createDefaultART();
            var trainingData = new Pattern[]{new DenseVector(new double[]{0.1, 0.2})};
            art.fit(trainingData);
            
            var wrongDimInput = new DenseVector(new double[]{0.1, 0.2, 0.3});
            
            assertThatThrownBy(() -> art.predict(wrongDimInput))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("dimension");
        }
        
        @Test
        @DisplayName("Should handle degenerate ellipsoids gracefully")
        void shouldHandleDegenerateEllipsoids() {
            var art = createDefaultART();
            
            // All identical points (should create degenerate ellipsoid)
            var identicalData = new Pattern[]{
                new DenseVector(new double[]{0.5, 0.5}),
                new DenseVector(new double[]{0.5, 0.5}),
                new DenseVector(new double[]{0.5, 0.5})
            };
            
            assertThatCode(() -> art.fit(identicalData))
                .as("Should handle identical points without error")
                .doesNotThrowAnyException();
            
            var testPoint = new DenseVector(new double[]{0.5, 0.5});
            var result = art.predict(testPoint);
            
            assertThat(result.activationValue())
                .as("Should provide valid activation for degenerate case")
                .isFinite()
                .isPositive();
        }
        
        @Test
        @DisplayName("Should handle extreme variance values")
        void shouldHandleExtremeVarianceValues() {
            var art = createDefaultART();
            
            // Data with extreme spread
            var extremeData = new Pattern[]{
                new DenseVector(new double[]{-100.0, -100.0}),
                new DenseVector(new double[]{100.0, 100.0}),
                new DenseVector(new double[]{0.0, 0.0})
            };
            
            assertThatCode(() -> art.fit(extremeData))
                .as("Should handle extreme variance without numerical issues")
                .doesNotThrowAnyException();
            
            assertThat(art.getCategoryCount())
                .as("Should create appropriate number of categories")
                .isPositive();
        }
    }
    
    @Nested
    @DisplayName("Integration Tests")
    class IntegrationTests {
        
        @Test
        @DisplayName("Should integrate with BaseART framework")
        void shouldIntegrateWithBaseARTFramework() {
            var art = createDefaultART();
            
            assertThat(art).isInstanceOf(BaseART.class);
            assertThat(art).isInstanceOf(ScikitClusterer.class);
            
            var testData = generateTestData(50, 2);
            art.fit(testData);
            
            assertThat(art.is_fitted()).isTrue();
            assertThat(art.getCategoryCount()).isGreaterThan(0);
            assertThat(art.getCategories()).hasSizeGreaterThan(0);
        }
        
        @Test
        @DisplayName("Should provide visualization-friendly data")
        void shouldProvideVisualizationData() {
            var art = createDefaultART();
            var data = generateTestData(100, 2);
            art.fit(data);
            
            // Should provide ellipsoid parameters for visualization
            var ellipsoids = art.getEllipsoidParameters();
            assertThat(ellipsoids).hasSizeGreaterThan(0);
            
            for (var ellipsoid : ellipsoids) {
                assertThat(ellipsoid.center())
                    .as("Ellipsoid center should be valid")
                    .isNotNull();
                
                assertThat(ellipsoid.covariance().determinant())
                    .as("Ellipsoid should have positive definite covariance")
                    .isPositive();
            }
        }
        
        @Test
        @DisplayName("Should support serialization and deserialization")
        void shouldSupportSerialization() {
            var art = createDefaultART();
            var data = generateTestData(50, 2);
            art.fit(data);
            
            // Serialize
            var serializedData = art.serialize();
            assertThat(serializedData)
                .as("Should produce non-empty serialization")
                .isNotBlank();
            
            // Deserialize
            var deserializedART = EllipsoidART.deserialize(serializedData);
            assertThat(deserializedART.getCategoryCount())
                .isEqualTo(art.getCategoryCount());
            assertThat(deserializedART.is_fitted())
                .isTrue();
            
            // Should produce same predictions
            var testData = generateTestData(10, 2);
            var originalPredictions = art.predict(testData);
            var deserializedPredictions = deserializedART.predict(testData);
            
            for (int i = 0; i < testData.length; i++) {
                assertThat(deserializedPredictions[i].categoryIndex())
                    .isEqualTo(originalPredictions[i].categoryIndex());
            }
        }
    }
    
    // Utility methods for test data generation and calculations
    private double[][] generateTestData(int numPoints, int dimensions) {
        var random = new Random(42); // Fixed seed for reproducibility
        var data = new double[numPoints][dimensions];
        
        // Create natural ellipsoidal clusters
        var numClusters = Math.min(3, Math.max(1, dimensions / 2));
        for (int i = 0; i < numPoints; i++) {
            int cluster = i % numClusters;
            for (int j = 0; j < dimensions; j++) {
                // Create elongated clusters with different orientations
                var baseValue = cluster * 0.6;
                var noise = random.nextGaussian() * 0.08;
                if (j == 0) {
                    data[i][j] = baseValue + noise * 2.0; // More variance in first dimension
                } else {
                    data[i][j] = baseValue * 0.8 + noise;
                }
            }
        }
        return data;
    }
    
    private double calculateExpectedMahalanobisDistance(double[] diff, Matrix covariance) {
        try {
            var invCov = covariance.inverse();
            double distance = 0.0;
            for (int i = 0; i < diff.length; i++) {
                for (int j = 0; j < diff.length; j++) {
                    distance += diff[i] * invCov.get(i, j) * diff[j];
                }
            }
            return Math.sqrt(distance);
        } catch (Exception e) {
            return Double.POSITIVE_INFINITY; // Singular matrix case
        }
    }
}