/*
 * Copyright (c) 2025 Hal Hildebrand. All rights reserved.
 * 
 * This file is part of Java ART Neural Networks.
 * 
 * Java ART Neural Networks is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Java ART Neural Networks is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with Java ART Neural Networks. If not, see <https://www.gnu.org/licenses/>.
 */
package com.hellblazer.art.performance.algorithms;

import com.hellblazer.art.core.BaseARTMAP;
import com.hellblazer.art.core.Pattern;
import com.hellblazer.art.core.results.ActivationResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.TimeUnit;

/**
 * High-performance vectorized FuzzyARTMAP implementation for supervised learning.
 * 
 * VectorizedFuzzyARTMAP combines the strengths of FuzzyART clustering with
 * supervised learning through a map field that associates categories with class labels.
 * This implementation provides significant performance improvements through:
 * 
 * - SIMD-optimized fuzzy operations using Java Vector API
 * - Parallel processing for large category sets and batch operations
 * - Vectorized complement coding and fuzzy min/max operations
 * - Optimized match tracking for conflict resolution
 * - Cache-friendly data structures and memory management
 * 
 * Key Features:
 * - Implements BaseARTMAP interface for supervised learning
 * - Composes VectorizedFuzzyART for high-performance clustering
 * - Supports incremental learning with partial_fit
 * - Handles label conflicts through match tracking with vigilance adjustment
 * - Provides performance monitoring and resource management
 * 
 * Architecture:
 * - Module A: VectorizedFuzzyART for input pattern clustering
 * - Map Field: Category-to-label associations for supervised learning
 * - Match Tracking: Conflict resolution through vigilance parameter adjustment
 * 
 * This implementation maintains full compatibility with FuzzyARTMAP semantics
 * while achieving 2-5x performance improvements on modern hardware.
 * 
 * @author Hal Hildebrand
 */
public class VectorizedFuzzyARTMAP implements BaseARTMAP, AutoCloseable {
    
    private static final Logger log = LoggerFactory.getLogger(VectorizedFuzzyARTMAP.class);
    
    // Core components
    private final VectorizedFuzzyART moduleA;           // A-side: Input pattern clustering
    private final Map<Integer, Integer> mapField;       // Map field: category -> label
    private final Map<Integer, Set<Integer>> labelCategories; // Reverse map: label -> categories
    
    // Training state
    private boolean trained = false;
    private int[] trainingLabels;                       // Store all training labels
    private final Set<Integer> knownLabels;             // Set of encountered labels
    
    // Parallel processing
    private final ForkJoinPool computePool;
    
    // Performance tracking
    private long totalSupervisedOperations = 0;
    private long totalMatchTrackingEvents = 0;
    private double avgSupervisedTime = 0.0;
    private final Map<String, Long> operationCounts;
    
    /**
     * Create a new VectorizedFuzzyARTMAP with default configuration.
     * 
     * Uses system-optimized parameters for balanced performance and accuracy.
     */
    public VectorizedFuzzyARTMAP() {
        this(VectorizedFuzzyARTMAPParameters.createDefault());
    }
    
    /**
     * Create a new VectorizedFuzzyARTMAP with specified default parameters.
     * 
     * @param defaultParams default parameters for the ARTMAP system
     */
    public VectorizedFuzzyARTMAP(VectorizedFuzzyARTMAPParameters defaultParams) {
        Objects.requireNonNull(defaultParams, "Default parameters cannot be null");
        defaultParams.validate();
        
        // Create VectorizedParameters for the underlying FuzzyART module
        var fuzzyParams = VectorizedParameters.createDefault()
            .withVigilance(defaultParams.rho())
            .withLearningRate(defaultParams.beta()) 
            .withParallelismLevel(defaultParams.parallelismLevel())
            .withCacheSettings(1000, defaultParams.enableSIMD(), true);
        
        this.moduleA = new VectorizedFuzzyART(fuzzyParams);
        this.mapField = new ConcurrentHashMap<>();
        this.labelCategories = new ConcurrentHashMap<>();
        this.knownLabels = ConcurrentHashMap.newKeySet();
        this.computePool = new ForkJoinPool(defaultParams.parallelismLevel());
        this.operationCounts = new ConcurrentHashMap<>();
        
        log.info("Initialized VectorizedFuzzyARTMAP with parameters: {}", defaultParams);
    }
    
    /**
     * Train the ARTMAP on labeled data.
     * 
     * @param data array of input patterns (should be complement coded)
     * @param labels array of class labels corresponding to each pattern
     * @param params parameters for training
     * @throws IllegalArgumentException if data and labels have different lengths
     * @throws NullPointerException if any parameter is null
     */
    public void fit(Pattern[] data, int[] labels, VectorizedFuzzyARTMAPParameters params) {
        Objects.requireNonNull(data, "Data cannot be null");
        Objects.requireNonNull(labels, "Labels cannot be null");
        Objects.requireNonNull(params, "Parameters cannot be null");
        
        if (data.length == 0) {
            throw new IllegalArgumentException("Cannot fit with empty data");
        }
        
        if (data.length != labels.length) {
            throw new IllegalArgumentException(
                "Data and labels must have same length: " + data.length + " != " + labels.length);
        }
        
        params.validate();
        
        long startTime = System.nanoTime();
        
        // Clear existing state
        clear();
        