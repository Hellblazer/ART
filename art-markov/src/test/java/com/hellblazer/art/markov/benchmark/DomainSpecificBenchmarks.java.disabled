package com.hellblazer.art.hybrid.markov.benchmark;

import com.hellblazer.art.hybrid.markov.HybridARTMarkov;
import com.hellblazer.art.hybrid.markov.baseline.StandardMarkovChain;
import org.junit.jupiter.api.Test;

import java.util.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Domain-specific benchmarks for real-world applications.
 *
 * Tests both standard and hybrid ART-Markov approaches on realistic scenarios:
 * - Game AI state transitions (exploration, combat, trading)
 * - Dialog system state management
 * - Robot navigation scenarios
 * - Financial state modeling (market regimes)
 */
public class DomainSpecificBenchmarks {

    /**
     * Domain benchmark result
     */
    public static record DomainBenchmarkResult(
        String domainName,
        String scenario,
        double standardAccuracy,
        double hybridAccuracy,
        double standardLatency,
        double hybridLatency,
        Map<String, Double> domainSpecificMetrics,
        List<String> insights
    ) {}

    // Game AI Domain Tests

    @Test
    void testGameAIStateTransitions() {
        System.out.println("=== Game AI State Transitions Benchmark ===\n");

        var explorationResult = testGameExplorationPattern();
        var combatResult = testGameCombatPattern();
        var tradingResult = testGameTradingPattern();

        printDomainResult(explorationResult);
        printDomainResult(combatResult);
        printDomainResult(tradingResult);

        // Game AI should benefit from ART's state discovery capabilities
        assertTrue(explorationResult.hybridAccuracy() >= explorationResult.standardAccuracy() - 0.1,
                  "Hybrid approach should handle exploration patterns well");
    }

    private DomainBenchmarkResult testGameExplorationPattern() {
        // Model player behavior: EXPLORING -> FOUND_ITEM -> INVENTORY_MANAGEMENT -> EXPLORING
        //                      or EXPLORING -> ENCOUNTER_ENEMY -> COMBAT -> EXPLORING
        var gameStates = List.of("EXPLORING", "FOUND_ITEM", "INVENTORY_MANAGEMENT",
                               "ENCOUNTER_ENEMY", "COMBAT", "RESTING", "TRADING");

        var sequence = generateGameSequence(1000, gameStates);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(
            new HybridARTMarkov.HybridConfig(0.7, 20, 0.1, true, false)
        );

        // Train models
        var trainSequence = sequence.subList(0, 800);
        var testSequence = sequence.subList(800, 1000);

        long startTime = System.nanoTime();
        trainGameModels(standardModel, hybridModel, trainSequence);
        long trainTime = System.nanoTime() - startTime;

        // Evaluate
        var standardAccuracy = evaluateGameAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateGameAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Game AI",
            "Exploration Pattern",
            standardAccuracy,
            hybridAccuracy,
            trainTime / 1_000_000.0,
            trainTime / 1_000_000.0, // Similar for this test
            Map.of(
                "state_variety", (double) gameStates.size(),
                "sequence_complexity", calculateSequenceComplexity(trainSequence)
            ),
            List.of("Tested exploration-driven game AI behavior patterns")
        );
    }

    private DomainBenchmarkResult testGameCombatPattern() {
        // Combat sequence: IDLE -> DETECT_ENEMY -> APPROACH -> ATTACK -> EVALUATE -> (ATTACK|RETREAT) -> IDLE
        var combatStates = List.of("IDLE", "DETECT_ENEMY", "APPROACH", "ATTACK",
                                 "EVALUATE", "RETREAT", "HEAL", "VICTORY");

        var sequence = generateCombatSequence(800);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(
            new HybridARTMarkov.HybridConfig(0.6, 15, 0.15, true, false)
        );

        var trainSequence = sequence.subList(0, 600);
        var testSequence = sequence.subList(600, 800);

        trainGameModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateGameAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateGameAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Game AI",
            "Combat Pattern",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0, // Timing not measured for this test
            Map.of(
                "combat_complexity", calculateCombatComplexity(trainSequence),
                "state_transitions", (double) trainSequence.size()
            ),
            List.of("Tested combat decision-making patterns")
        );
    }

    private DomainBenchmarkResult testGameTradingPattern() {
        // Trading: BROWSING -> INSPECT_ITEM -> (BUY|SELL|NEGOTIATE) -> CONFIRM -> BROWSING
        var tradingStates = List.of("BROWSING", "INSPECT_ITEM", "BUY", "SELL",
                                  "NEGOTIATE", "CONFIRM", "CANCEL", "INVENTORY");

        var sequence = generateTradingSequence(600);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(HybridARTMarkov.HybridConfig.defaultConfig());

        var trainSequence = sequence.subList(0, 480);
        var testSequence = sequence.subList(480, 600);

        trainGameModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateGameAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateGameAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Game AI",
            "Trading Pattern",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of("trading_efficiency", calculateTradingEfficiency(trainSequence)),
            List.of("Tested economic decision patterns in games")
        );
    }

    // Dialog System Domain Tests

    @Test
    void testDialogSystemStateManagement() {
        System.out.println("=== Dialog System State Management Benchmark ===\n");

        var customerServiceResult = testCustomerServiceDialog();
        var chatbotResult = testChatbotConversation();
        var voiceAssistantResult = testVoiceAssistantDialog();

        printDomainResult(customerServiceResult);
        printDomainResult(chatbotResult);
        printDomainResult(voiceAssistantResult);

        // Dialog systems should benefit from context-aware state management
        assertTrue(customerServiceResult.hybridAccuracy() > 0.4,
                  "Dialog system should achieve reasonable accuracy");
    }

    private DomainBenchmarkResult testCustomerServiceDialog() {
        // Customer service flow: GREETING -> IDENTIFY_ISSUE -> GATHER_INFO -> RESOLVE -> FOLLOW_UP -> END
        var dialogStates = List.of("GREETING", "IDENTIFY_ISSUE", "GATHER_INFO",
                                 "RESOLVE", "ESCALATE", "FOLLOW_UP", "END", "TRANSFER");

        var sequence = generateCustomerServiceDialog(500);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(
            new HybridARTMarkov.HybridConfig(0.8, 25, 0.1, true, false)
        );

        var trainSequence = sequence.subList(0, 400);
        var testSequence = sequence.subList(400, 500);

        trainDialogModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateDialogAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateDialogAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Dialog System",
            "Customer Service",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of(
                "dialog_length", calculateAverageDialogLength(trainSequence),
                "resolution_rate", calculateResolutionRate(trainSequence)
            ),
            List.of("Tested customer service conversation flows")
        );
    }

    private DomainBenchmarkResult testChatbotConversation() {
        var chatSequence = generateChatbotDialog(400);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(HybridARTMarkov.HybridConfig.defaultConfig());

        var trainSequence = chatSequence.subList(0, 320);
        var testSequence = chatSequence.subList(320, 400);

        trainDialogModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateDialogAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateDialogAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Dialog System",
            "Chatbot Conversation",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of("conversation_depth", calculateConversationDepth(trainSequence)),
            List.of("Tested general chatbot conversation patterns")
        );
    }

    private DomainBenchmarkResult testVoiceAssistantDialog() {
        var voiceSequence = generateVoiceAssistantDialog(300);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(HybridARTMarkov.HybridConfig.defaultConfig());

        var trainSequence = voiceSequence.subList(0, 240);
        var testSequence = voiceSequence.subList(240, 300);

        trainDialogModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateDialogAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateDialogAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Dialog System",
            "Voice Assistant",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of("command_variety", 8.0),
            List.of("Tested voice command processing patterns")
        );
    }

    // Robot Navigation Domain Tests

    @Test
    void testRobotNavigationScenarios() {
        System.out.println("=== Robot Navigation Scenarios Benchmark ===\n");

        var gridWorldResult = testGridWorldNavigation();
        var obstacleAvoidanceResult = testObstacleAvoidanceNavigation();
        var pathPlanningResult = testPathPlanningNavigation();

        printDomainResult(gridWorldResult);
        printDomainResult(obstacleAvoidanceResult);
        printDomainResult(pathPlanningResult);

        // Navigation should benefit from spatial state discovery
        assertTrue(gridWorldResult.hybridAccuracy() > 0.3,
                  "Navigation should achieve reasonable accuracy");
    }

    private DomainBenchmarkResult testGridWorldNavigation() {
        // Grid positions as states, with movement actions
        var navigationSequence = generateGridWorldNavigation(600, 10, 10);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(
            new HybridARTMarkov.HybridConfig(0.5, 100, 0.1, true, false)
        );

        var trainSequence = navigationSequence.subList(0, 480);
        var testSequence = navigationSequence.subList(480, 600);

        trainNavigationModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateNavigationAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateNavigationAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Robot Navigation",
            "Grid World",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of(
                "grid_size", 100.0,
                "path_efficiency", calculatePathEfficiency(trainSequence)
            ),
            List.of("Tested grid-based robot navigation")
        );
    }

    private DomainBenchmarkResult testObstacleAvoidanceNavigation() {
        var obstacleSequence = generateObstacleAvoidanceSequence(400);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(HybridARTMarkov.HybridConfig.defaultConfig());

        var trainSequence = obstacleSequence.subList(0, 320);
        var testSequence = obstacleSequence.subList(320, 400);

        trainNavigationModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateNavigationAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateNavigationAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Robot Navigation",
            "Obstacle Avoidance",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of("obstacle_density", 0.3),
            List.of("Tested obstacle avoidance behaviors")
        );
    }

    private DomainBenchmarkResult testPathPlanningNavigation() {
        var pathSequence = generatePathPlanningSequence(500);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(HybridARTMarkov.HybridConfig.defaultConfig());

        var trainSequence = pathSequence.subList(0, 400);
        var testSequence = pathSequence.subList(400, 500);

        trainNavigationModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateNavigationAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateNavigationAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Robot Navigation",
            "Path Planning",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of("planning_complexity", calculatePlanningComplexity(trainSequence)),
            List.of("Tested multi-goal path planning")
        );
    }

    // Financial Domain Tests

    @Test
    void testFinancialStateModeling() {
        System.out.println("=== Financial State Modeling Benchmark ===\n");

        var marketRegimeResult = testMarketRegimeDetection();
        var portfolioStateResult = testPortfolioStateTransitions();
        var riskModelResult = testRiskStateModeling();

        printDomainResult(marketRegimeResult);
        printDomainResult(portfolioStateResult);
        printDomainResult(riskModelResult);

        // Financial models should handle regime changes well
        assertTrue(marketRegimeResult.hybridAccuracy() > 0.3,
                  "Financial regime detection should achieve reasonable accuracy");
    }

    private DomainBenchmarkResult testMarketRegimeDetection() {
        // Market states: BULL, BEAR, SIDEWAYS, VOLATILE, CRISIS
        var marketSequence = generateMarketRegimeSequence(800);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(
            new HybridARTMarkov.HybridConfig(0.7, 15, 0.05, true, false)
        );

        var trainSequence = marketSequence.subList(0, 640);
        var testSequence = marketSequence.subList(640, 800);

        trainFinancialModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateFinancialAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateFinancialAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Financial Modeling",
            "Market Regime Detection",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of(
                "regime_stability", calculateRegimeStability(trainSequence),
                "transition_frequency", calculateTransitionFrequency(trainSequence)
            ),
            List.of("Tested market regime identification and transitions")
        );
    }

    private DomainBenchmarkResult testPortfolioStateTransitions() {
        var portfolioSequence = generatePortfolioStateSequence(600);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(HybridARTMarkov.HybridConfig.defaultConfig());

        var trainSequence = portfolioSequence.subList(0, 480);
        var testSequence = portfolioSequence.subList(480, 600);

        trainFinancialModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateFinancialAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateFinancialAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Financial Modeling",
            "Portfolio State Transitions",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of("portfolio_diversity", 0.8),
            List.of("Tested portfolio rebalancing state transitions")
        );
    }

    private DomainBenchmarkResult testRiskStateModeling() {
        var riskSequence = generateRiskStateSequence(500);

        var standardModel = new StandardMarkovChain<String>();
        var hybridModel = new HybridARTMarkov<String>(HybridARTMarkov.HybridConfig.defaultConfig());

        var trainSequence = riskSequence.subList(0, 400);
        var testSequence = riskSequence.subList(400, 500);

        trainFinancialModels(standardModel, hybridModel, trainSequence);

        var standardAccuracy = evaluateFinancialAccuracy(standardModel, testSequence);
        var hybridAccuracy = evaluateFinancialAccuracy(hybridModel, testSequence);

        hybridModel.close();

        return new DomainBenchmarkResult(
            "Financial Modeling",
            "Risk State Modeling",
            standardAccuracy,
            hybridAccuracy,
            0.0, 0.0,
            Map.of("risk_volatility", calculateRiskVolatility(trainSequence)),
            List.of("Tested risk level state transitions")
        );
    }

    // Helper methods for data generation

    private List<String> generateGameSequence(int length, List<String> states) {
        var sequence = new ArrayList<String>();
        var random = new Random(42);

        // Game-specific transition patterns
        var transitions = Map.of(
            "EXPLORING", List.of("FOUND_ITEM", "ENCOUNTER_ENEMY", "RESTING", "EXPLORING"),
            "FOUND_ITEM", List.of("INVENTORY_MANAGEMENT", "EXPLORING"),
            "INVENTORY_MANAGEMENT", List.of("EXPLORING", "TRADING"),
            "ENCOUNTER_ENEMY", List.of("COMBAT", "EXPLORING"),
            "COMBAT", List.of("RESTING", "EXPLORING", "ENCOUNTER_ENEMY"),
            "RESTING", List.of("EXPLORING"),
            "TRADING", List.of("EXPLORING", "INVENTORY_MANAGEMENT")
        );

        var currentState = "EXPLORING";
        sequence.add(currentState);

        for (int i = 1; i < length; i++) {
            var possibleNext = transitions.getOrDefault(currentState, states);
            currentState = possibleNext.get(random.nextInt(possibleNext.size()));
            sequence.add(currentState);
        }

        return sequence;
    }

    private List<String> generateCombatSequence(int length) {
        var sequence = new ArrayList<String>();
        var random = new Random(42);
        var combatStates = List.of("IDLE", "DETECT_ENEMY", "APPROACH", "ATTACK",
                                 "EVALUATE", "RETREAT", "HEAL", "VICTORY");

        // Combat has structured patterns
        var patterns = List.of(
            List.of("IDLE", "DETECT_ENEMY", "APPROACH", "ATTACK", "EVALUATE", "ATTACK", "VICTORY", "IDLE"),
            List.of("IDLE", "DETECT_ENEMY", "APPROACH", "ATTACK", "EVALUATE", "RETREAT", "HEAL", "IDLE"),
            List.of("IDLE", "DETECT_ENEMY", "APPROACH", "ATTACK", "VICTORY", "IDLE")
        );

        var patternIndex = 0;
        var stepInPattern = 0;

        for (int i = 0; i < length; i++) {
            var currentPattern = patterns.get(patternIndex % patterns.size());
            sequence.add(currentPattern.get(stepInPattern % currentPattern.size()));

            stepInPattern++;
            if (stepInPattern >= currentPattern.size()) {
                stepInPattern = 0;
                patternIndex = random.nextInt(patterns.size());
            }
        }

        return sequence;
    }

    private List<String> generateTradingSequence(int length) {
        // Implement trading sequence generation
        var tradingStates = List.of("BROWSING", "INSPECT_ITEM", "BUY", "SELL",
                                  "NEGOTIATE", "CONFIRM", "CANCEL", "INVENTORY");
        return generateSequenceWithPattern(length, tradingStates, 42);
    }

    private List<String> generateCustomerServiceDialog(int length) {
        var dialogStates = List.of("GREETING", "IDENTIFY_ISSUE", "GATHER_INFO",
                                 "RESOLVE", "ESCALATE", "FOLLOW_UP", "END", "TRANSFER");
        return generateSequenceWithPattern(length, dialogStates, 43);
    }

    private List<String> generateChatbotDialog(int length) {
        var chatStates = List.of("GREETING", "UNDERSTAND_INTENT", "PROVIDE_INFO",
                               "CLARIFY", "CONFIRM", "END", "FALLBACK");
        return generateSequenceWithPattern(length, chatStates, 44);
    }

    private List<String> generateVoiceAssistantDialog(int length) {
        var voiceStates = List.of("WAKE_WORD", "LISTEN", "PROCESS", "RESPOND",
                                "CONFIRM", "EXECUTE", "FEEDBACK", "SLEEP");
        return generateSequenceWithPattern(length, voiceStates, 45);
    }

    private List<String> generateGridWorldNavigation(int length, int width, int height) {
        var sequence = new ArrayList<String>();
        var random = new Random(46);

        int x = random.nextInt(width);
        int y = random.nextInt(height);

        for (int i = 0; i < length; i++) {
            sequence.add(String.format("POS_%d_%d", x, y));

            // Random walk with some goal-seeking behavior
            var direction = random.nextInt(4);
            switch (direction) {
                case 0 -> x = Math.max(0, x - 1);       // Left
                case 1 -> x = Math.min(width - 1, x + 1); // Right
                case 2 -> y = Math.max(0, y - 1);       // Up
                case 3 -> y = Math.min(height - 1, y + 1); // Down
            }
        }

        return sequence;
    }

    private List<String> generateObstacleAvoidanceSequence(int length) {
        var navStates = List.of("FORWARD", "LEFT", "RIGHT", "BACK", "STOP", "SCAN", "TURN_AROUND");
        return generateSequenceWithPattern(length, navStates, 47);
    }

    private List<String> generatePathPlanningSequence(int length) {
        var planStates = List.of("PLAN", "EXECUTE", "MONITOR", "REPLAN", "ARRIVE", "NAVIGATE");
        return generateSequenceWithPattern(length, planStates, 48);
    }

    private List<String> generateMarketRegimeSequence(int length) {
        var marketStates = List.of("BULL", "BEAR", "SIDEWAYS", "VOLATILE", "CRISIS", "RECOVERY");

        // Market regimes have persistence
        var sequence = new ArrayList<String>();
        var random = new Random(49);
        var currentState = "SIDEWAYS";
        var stateCounter = 0;
        var minStateLength = 10; // Markets stay in regimes for a while

        for (int i = 0; i < length; i++) {
            sequence.add(currentState);
            stateCounter++;

            if (stateCounter >= minStateLength && random.nextDouble() < 0.1) {
                // Transition to new state
                currentState = marketStates.get(random.nextInt(marketStates.size()));
                stateCounter = 0;
                minStateLength = 5 + random.nextInt(20); // Variable regime lengths
            }
        }

        return sequence;
    }

    private List<String> generatePortfolioStateSequence(int length) {
        var portfolioStates = List.of("CONSERVATIVE", "BALANCED", "AGGRESSIVE", "DEFENSIVE", "REBALANCING");
        return generateSequenceWithPattern(length, portfolioStates, 50);
    }

    private List<String> generateRiskStateSequence(int length) {
        var riskStates = List.of("LOW_RISK", "MEDIUM_RISK", "HIGH_RISK", "EXTREME_RISK", "CRISIS");
        return generateSequenceWithPattern(length, riskStates, 51);
    }

    private List<String> generateSequenceWithPattern(int length, List<String> states, int seed) {
        var sequence = new ArrayList<String>();
        var random = new Random(seed);
        var currentState = states.get(0);

        for (int i = 0; i < length; i++) {
            sequence.add(currentState);

            // Weighted transition to next state
            if (random.nextDouble() < 0.7) {
                // Stay in current state or move to next logical state
                var currentIndex = states.indexOf(currentState);
                var nextIndex = (currentIndex + 1) % states.size();
                currentState = states.get(nextIndex);
            } else {
                // Random transition
                currentState = states.get(random.nextInt(states.size()));
            }
        }

        return sequence;
    }

    // Training and evaluation helper methods

    private <T> void trainGameModels(StandardMarkovChain<T> standardModel,
                                    HybridARTMarkov<T> hybridModel,
                                    List<T> sequence) {
        trainModels(standardModel, hybridModel, sequence);
    }

    private <T> void trainDialogModels(StandardMarkovChain<T> standardModel,
                                      HybridARTMarkov<T> hybridModel,
                                      List<T> sequence) {
        trainModels(standardModel, hybridModel, sequence);
    }

    private <T> void trainNavigationModels(StandardMarkovChain<T> standardModel,
                                          HybridARTMarkov<T> hybridModel,
                                          List<T> sequence) {
        trainModels(standardModel, hybridModel, sequence);
    }

    private <T> void trainFinancialModels(StandardMarkovChain<T> standardModel,
                                         HybridARTMarkov<T> hybridModel,
                                         List<T> sequence) {
        trainModels(standardModel, hybridModel, sequence);
    }

    private <T> void trainModels(StandardMarkovChain<T> standardModel,
                                HybridARTMarkov<T> hybridModel,
                                List<T> sequence) {
        // Train standard model
        for (int i = 1; i < sequence.size(); i++) {
            standardModel.observeTransition(sequence.get(i-1), sequence.get(i));
        }

        // Train hybrid model
        for (var observation : sequence) {
            hybridModel.processObservation(observation);
        }
    }

    private <T> double evaluateGameAccuracy(StandardMarkovChain<T> model, List<T> testSequence) {
        return evaluateAccuracy(model, testSequence);
    }

    private <T> double evaluateDialogAccuracy(StandardMarkovChain<T> model, List<T> testSequence) {
        return evaluateAccuracy(model, testSequence);
    }

    private <T> double evaluateNavigationAccuracy(StandardMarkovChain<T> model, List<T> testSequence) {
        return evaluateAccuracy(model, testSequence);
    }

    private <T> double evaluateFinancialAccuracy(StandardMarkovChain<T> model, List<T> testSequence) {
        return evaluateAccuracy(model, testSequence);
    }

    private <T> double evaluateAccuracy(StandardMarkovChain<T> model, List<T> testSequence) {
        if (testSequence.size() < 2) return 0.0;

        var correctPredictions = 0;
        for (int i = 1; i < testSequence.size(); i++) {
            var predicted = model.predictNextState(testSequence.get(i-1));
            if (Objects.equals(predicted, testSequence.get(i))) {
                correctPredictions++;
            }
        }

        return (double) correctPredictions / (testSequence.size() - 1);
    }

    // Domain-specific metric calculations

    private double calculateSequenceComplexity(List<String> sequence) {
        var uniqueStates = new HashSet<>(sequence);
        var transitions = new HashSet<String>();

        for (int i = 1; i < sequence.size(); i++) {
            transitions.add(sequence.get(i-1) + "->" + sequence.get(i));
        }

        return (double) transitions.size() / (uniqueStates.size() * uniqueStates.size());
    }

    private double calculateCombatComplexity(List<String> sequence) {
        return calculateTransitionEntropy(sequence);
    }

    private double calculateTradingEfficiency(List<String> sequence) {
        long completedTransactions = sequence.stream()
            .mapToLong(state -> "CONFIRM".equals(state) ? 1 : 0)
            .sum();
        return (double) completedTransactions / sequence.size();
    }

    private double calculateAverageDialogLength(List<String> sequence) {
        // Count dialog sessions (ending states)
        long dialogEnds = sequence.stream()
            .mapToLong(state -> "END".equals(state) ? 1 : 0)
            .sum();
        return dialogEnds > 0 ? (double) sequence.size() / dialogEnds : 0.0;
    }

    private double calculateResolutionRate(List<String> sequence) {
        long resolutions = sequence.stream()
            .mapToLong(state -> "RESOLVE".equals(state) ? 1 : 0)
            .sum();
        long total = sequence.stream()
            .mapToLong(state -> Arrays.asList("RESOLVE", "ESCALATE", "TRANSFER").contains(state) ? 1 : 0)
            .sum();
        return total > 0 ? (double) resolutions / total : 0.0;
    }

    private double calculateConversationDepth(List<String> sequence) {
        return calculateTransitionEntropy(sequence);
    }

    private double calculatePathEfficiency(List<String> sequence) {
        // Simple efficiency: fewer state changes = more efficient
        var stateChanges = 0;
        for (int i = 1; i < sequence.size(); i++) {
            if (!sequence.get(i-1).equals(sequence.get(i))) {
                stateChanges++;
            }
        }
        return 1.0 - ((double) stateChanges / sequence.size());
    }

    private double calculatePlanningComplexity(List<String> sequence) {
        long planSteps = sequence.stream()
            .mapToLong(state -> "PLAN".equals(state) || "REPLAN".equals(state) ? 1 : 0)
            .sum();
        return (double) planSteps / sequence.size();
    }

    private double calculateRegimeStability(List<String> sequence) {
        var stateChanges = 0;
        for (int i = 1; i < sequence.size(); i++) {
            if (!sequence.get(i-1).equals(sequence.get(i))) {
                stateChanges++;
            }
        }
        return 1.0 - ((double) stateChanges / sequence.size());
    }

    private double calculateTransitionFrequency(List<String> sequence) {
        var transitions = new HashSet<String>();
        for (int i = 1; i < sequence.size(); i++) {
            transitions.add(sequence.get(i-1) + "->" + sequence.get(i));
        }
        return (double) transitions.size() / (sequence.size() - 1);
    }

    private double calculateRiskVolatility(List<String> sequence) {
        return calculateTransitionEntropy(sequence);
    }

    private double calculateTransitionEntropy(List<String> sequence) {
        var transitionCounts = new HashMap<String, Integer>();
        var totalTransitions = 0;

        for (int i = 1; i < sequence.size(); i++) {
            var transition = sequence.get(i-1) + "->" + sequence.get(i);
            transitionCounts.merge(transition, 1, Integer::sum);
            totalTransitions++;
        }

        if (totalTransitions == 0) return 0.0;

        var entropy = 0.0;
        for (var count : transitionCounts.values()) {
            var probability = (double) count / totalTransitions;
            entropy -= probability * Math.log(probability) / Math.log(2);
        }

        return entropy;
    }

    private void printDomainResult(DomainBenchmarkResult result) {
        System.out.printf("Domain: %s - %s\n", result.domainName(), result.scenario());
        System.out.printf("  Standard Accuracy: %.4f\n", result.standardAccuracy());
        System.out.printf("  Hybrid Accuracy: %.4f\n", result.hybridAccuracy());
        System.out.printf("  Improvement: %.4f\n", result.hybridAccuracy() - result.standardAccuracy());

        if (!result.domainSpecificMetrics().isEmpty()) {
            System.out.println("  Domain Metrics:");
            result.domainSpecificMetrics().forEach((key, value) ->
                System.out.printf("    %s: %.4f\n", key, value));
        }

        if (!result.insights().isEmpty()) {
            System.out.println("  Insights:");
            result.insights().forEach(insight -> System.out.println("    " + insight));
        }

        System.out.println();
    }
}