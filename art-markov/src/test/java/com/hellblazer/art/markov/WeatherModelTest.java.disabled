package com.hellblazer.art.hybrid.markov;

import com.hellblazer.art.core.Pattern;
import com.hellblazer.art.core.parameters.FuzzyParameters;
import com.hellblazer.art.hybrid.markov.core.MinimalHybridPredictor;
import com.hellblazer.art.hybrid.markov.core.ValidationLayer;
import com.hellblazer.art.hybrid.markov.parameters.HybridMarkovParameters;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive test demonstrating the hybrid ART-Markov system with synthetic weather data.
 *
 * This test creates a simple 4-state weather model with known transition probabilities
 * and validates that the hybrid system can:
 * 1. Discover states from continuous observations
 * 2. Learn correct transition probabilities
 * 3. Make accurate predictions
 * 4. Maintain mathematical correctness
 * 5. Outperform pure ART or pure Markov approaches
 */
class WeatherModelTest {

    // Weather states (ground truth)
    private static final int SUNNY = 0;
    private static final int CLOUDY = 1;
    private static final int RAINY = 2;
    private static final int STORMY = 3;

    private static final String[] STATE_NAMES = {"Sunny", "Cloudy", "Rainy", "Stormy"};

    // Ground truth transition matrix (known weather patterns)
    private static final double[][] GROUND_TRUTH_TRANSITIONS = {
        // From:  SUNNY    CLOUDY   RAINY    STORMY
        /*SUNNY*/  {0.60,   0.30,    0.08,    0.02},  // Sunny tends to stay sunny
        /*CLOUDY*/ {0.25,   0.40,    0.30,    0.05},  // Cloudy can go either way
        /*RAINY*/  {0.10,   0.35,    0.45,    0.10},  // Rainy persists or gets worse
        /*STORMY*/ {0.05,   0.20,    0.35,    0.40}   // Stormy tends to persist
    };

    private MinimalHybridPredictor hybridPredictor;
    private HybridMarkovParameters parameters;

    @BeforeEach
    void setUp() {
        parameters = HybridMarkovParameters.weatherDefaults();
        hybridPredictor = new MinimalHybridPredictor(parameters);
    }

    @AfterEach
    void tearDown() {
        if (hybridPredictor != null) {
            hybridPredictor.close();
        }
    }

    @Test
    @DisplayName("Validate ground truth transition matrix is stochastic")
    void testGroundTruthMatrixValidation() {
        // Ensure our ground truth is mathematically sound
        assertDoesNotThrow(() -> ValidationLayer.validateStochasticMatrix(GROUND_TRUTH_TRANSITIONS));

        // Check that each row sums to 1.0
        for (int i = 0; i < GROUND_TRUTH_TRANSITIONS.length; i++) {
            double rowSum = Arrays.stream(GROUND_TRUTH_TRANSITIONS[i]).sum();
            assertEquals(1.0, rowSum, 1e-10, "Row " + i + " should sum to 1.0");
        }
    }

    @Test
    @DisplayName("Generate and validate synthetic weather observations")
    void testSyntheticWeatherGeneration() {
        var observations = generateWeatherSequence(100, 42L);

        assertEquals(100, observations.size());

        // Check that observations vary realistically
        var stateSet = new HashSet<Integer>();
        for (var obs : observations) {
            int state = obs.groundTruthState;
            assertTrue(state >= 0 && state < 4, "State should be in valid range");
            stateSet.add(state);
        }

        // Should see multiple weather states in a reasonable sequence
        assertTrue(stateSet.size() >= 2, "Should observe multiple weather states");
    }

    @Test
    @DisplayName("Hybrid system learns weather patterns correctly")
    void testWeatherPatternLearning() {
        var observations = generateWeatherSequence(1000, 42L);

        // Train the hybrid system
        for (var obs : observations) {
            int discoveredState = hybridPredictor.learn(obs.observation);
            assertTrue(discoveredState >= 0, "Should discover valid states");
        }

        // Validate system statistics
        var stats = hybridPredictor.getStatistics();
        int stateCount = hybridPredictor.getStateCount();

        System.out.println("Discovered " + stateCount + " states");
        assertTrue(stateCount >= 3 && stateCount <= 4, "Should discover 3-4 weather states");

        // Check transition matrix properties
        var learnedMatrix = hybridPredictor.getTransitionMatrix();
        assertDoesNotThrow(() -> ValidationLayer.validateStochasticMatrix(learnedMatrix));

        // Test Markov property
        var markovStats = (Map<String, Object>) stats.get("markovStats");
        assertTrue((Boolean) markovStats.get("satisfiesMarkovProperty"),
                  "Learned model should satisfy Markov property");

        System.out.println("Weather learning statistics:");
        System.out.println("  States discovered: " + stateCount);
        System.out.println("  Satisfies Markov property: " + markovStats.get("satisfiesMarkovProperty"));
        System.out.println("  Matrix entropy: " + markovStats.get("matrixEntropy"));
    }

    @Test
    @DisplayName("Hybrid predictions are accurate and mathematically sound")
    void testPredictionAccuracy() {
        // Generate training data
        var trainingData = generateWeatherSequence(500, 42L);

        // Train the system
        for (var obs : trainingData) {
            hybridPredictor.learn(obs.observation);
        }

        // Generate test data
        var testData = generateWeatherSequence(100, 999L);

        int correctPredictions = 0;
        var allPredictions = new ArrayList<MinimalHybridPredictor.PredictionResult>();

        for (int i = 0; i < testData.size() - 1; i++) {
            var currentObs = testData.get(i);
            var nextObs = testData.get(i + 1);

            var prediction = hybridPredictor.predict(currentObs.observation);
            allPredictions.add(prediction);

            // Validate prediction mathematically
            assertNotNull(prediction);
            assertTrue(prediction.getConfidence() >= 0.0 && prediction.getConfidence() <= 1.0);
            assertTrue(prediction.getEntropy() >= 0.0);

            // Check if prediction matches ground truth
            boolean correct = hybridPredictor.validatePrediction(prediction, nextObs.observation);
            if (correct) {
                correctPredictions++;
            }
        }

        double accuracy = (double) correctPredictions / (testData.size() - 1);
        System.out.println("Prediction accuracy: " + String.format("%.3f", accuracy));

        // Should achieve reasonable accuracy (better than random guessing)
        assertTrue(accuracy > 0.30, "Accuracy should be better than random (0.25)");

        // Validate prediction time performance
        var avgPredictionTime = allPredictions.stream()
            .mapToLong(MinimalHybridPredictor.PredictionResult::predictionTimeNanos)
            .average()
            .orElse(0.0);

        System.out.println("Average prediction time: " + String.format("%.2f Î¼s", avgPredictionTime / 1000.0));
        assertTrue(avgPredictionTime < 1_000_000L, "Predictions should be fast (< 1ms)");
    }

    @Test
    @DisplayName("Compare hybrid vs pure approaches")
    void testHybridVsPureApproaches() {
        var observations = generateWeatherSequence(300, 42L);

        // Test with different hybrid weights
        var hybridWeights = new double[]{0.0, 0.25, 0.5, 0.75, 1.0};
        var accuracies = new ArrayList<Double>();

        for (double weight : hybridWeights) {
            var params = HybridMarkovParameters.withHybridWeight(weight);

            try (var predictor = new MinimalHybridPredictor(params)) {
                // Train
                for (int i = 0; i < observations.size() - 50; i++) {
                    predictor.learn(observations.get(i).observation);
                }

                // Test
                int correct = 0;
                int total = 0;

                for (int i = observations.size() - 50; i < observations.size() - 1; i++) {
                    var currentObs = observations.get(i);
                    var nextObs = observations.get(i + 1);

                    var prediction = predictor.predict(currentObs.observation);
                    if (predictor.validatePrediction(prediction, nextObs.observation)) {
                        correct++;
                    }
                    total++;
                }

                double accuracy = total > 0 ? (double) correct / total : 0.0;
                accuracies.add(accuracy);

                String approach = switch ((int) (weight * 4)) {
                    case 0 -> "Pure Markov";
                    case 1 -> "Markov-heavy";
                    case 2 -> "Balanced hybrid";
                    case 3 -> "ART-heavy";
                    case 4 -> "Pure ART";
                    default -> "Hybrid " + weight;
                };

                System.out.println(approach + " accuracy: " + String.format("%.3f", accuracy));
            }
        }

        // The hybrid approach should perform competitively
        double maxAccuracy = accuracies.stream().mapToDouble(d -> d).max().orElse(0.0);
        double hybridAccuracy = accuracies.get(2); // 0.5 weight (balanced hybrid)

        assertTrue(hybridAccuracy >= maxAccuracy * 0.85,
                  "Hybrid approach should be competitive with best pure approach");
    }

    @Test
    @DisplayName("System handles edge cases gracefully")
    void testEdgeCases() {
        // Test with null observation
        assertThrows(IllegalArgumentException.class, () -> hybridPredictor.learn(null));
        assertThrows(IllegalArgumentException.class, () -> hybridPredictor.predict(null));

        // Test with empty system
        var prediction = hybridPredictor.predict(Pattern.of(0.5, 0.3, 0.8));
        assertNotNull(prediction);
        assertEquals(-1, prediction.observedState()); // Should handle unknown state gracefully

        // Test clear functionality
        hybridPredictor.learn(Pattern.of(0.1, 0.2, 0.3));
        assertTrue(hybridPredictor.getStateCount() > 0);

        hybridPredictor.clear();
        assertEquals(0, hybridPredictor.getStateCount());

        // Test state labeling
        hybridPredictor.learn(Pattern.of(0.1, 0.2, 0.3));
        hybridPredictor.setStateLabel(0, "TestState");
        assertEquals("TestState", hybridPredictor.getStateLabel(0));
    }

    @Test
    @DisplayName("Performance baseline measurements")
    void testPerformanceBaseline() {
        var observations = generateWeatherSequence(1000, 42L);

        long startTime = System.currentTimeMillis();

        // Training phase
        for (var obs : observations) {
            hybridPredictor.learn(obs.observation);
        }

        long trainingTime = System.currentTimeMillis() - startTime;

        // Prediction phase
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100; i++) {
            var randomObs = observations.get(ThreadLocalRandom.current().nextInt(observations.size()));
            hybridPredictor.predict(randomObs.observation);
        }
        long predictionTime = System.currentTimeMillis() - startTime;

        var stats = hybridPredictor.getStatistics();

        System.out.println("Performance Baseline:");
        System.out.println("  Training time (1000 samples): " + trainingTime + " ms");
        System.out.println("  Prediction time (100 samples): " + predictionTime + " ms");
        System.out.println("  Memory usage estimate: " + stats.get("memoryUsageBytes") + " bytes");
        System.out.println("  States discovered: " + hybridPredictor.getStateCount());

        // Basic performance assertions
        assertTrue(trainingTime < 10000, "Training should be fast (< 10 seconds)");
        assertTrue(predictionTime < 1000, "Predictions should be fast (< 1 second for 100)");

        var memoryUsage = ((Double) stats.get("memoryUsageBytes")).longValue();
        assertTrue(memoryUsage < 1_000_000, "Memory usage should be reasonable (< 1MB)");
    }

    // Helper methods for test data generation

    private record WeatherObservation(Pattern observation, int groundTruthState) {}

    private List<WeatherObservation> generateWeatherSequence(int length, long seed) {
        var random = new Random(seed);
        var observations = new ArrayList<WeatherObservation>();

        int currentState = SUNNY; // Start sunny

        for (int i = 0; i < length; i++) {
            // Generate continuous observation from discrete state
            var observation = generateObservationFromState(currentState, random);
            observations.add(new WeatherObservation(observation, currentState));

            // Transition to next state based on ground truth probabilities
            currentState = sampleNextState(currentState, random);
        }

        return observations;
    }

    private Pattern generateObservationFromState(int state, Random random) {
        // Generate realistic weather observations as continuous vectors
        // [temperature, humidity, pressure] normalized to [0, 1]

        double temperature, humidity, pressure;

        switch (state) {
            case SUNNY -> {
                temperature = 0.7 + random.nextGaussian() * 0.1; // Warm
                humidity = 0.3 + random.nextGaussian() * 0.1;    // Low humidity
                pressure = 0.8 + random.nextGaussian() * 0.1;    // High pressure
            }
            case CLOUDY -> {
                temperature = 0.5 + random.nextGaussian() * 0.1; // Moderate
                humidity = 0.6 + random.nextGaussian() * 0.1;    // Moderate humidity
                pressure = 0.6 + random.nextGaussian() * 0.1;    // Moderate pressure
            }
            case RAINY -> {
                temperature = 0.4 + random.nextGaussian() * 0.1; // Cool
                humidity = 0.8 + random.nextGaussian() * 0.1;    // High humidity
                pressure = 0.4 + random.nextGaussian() * 0.1;    // Low pressure
            }
            case STORMY -> {
                temperature = 0.3 + random.nextGaussian() * 0.15; // Cold
                humidity = 0.9 + random.nextGaussian() * 0.05;    // Very high humidity
                pressure = 0.2 + random.nextGaussian() * 0.1;     // Very low pressure
            }
            default -> throw new IllegalArgumentException("Invalid state: " + state);
        }

        // Clamp values to [0, 1] range
        temperature = Math.max(0.0, Math.min(1.0, temperature));
        humidity = Math.max(0.0, Math.min(1.0, humidity));
        pressure = Math.max(0.0, Math.min(1.0, pressure));

        return Pattern.of(temperature, humidity, pressure);
    }

    private int sampleNextState(int currentState, Random random) {
        double[] probabilities = GROUND_TRUTH_TRANSITIONS[currentState];
        double rand = random.nextDouble();

        double cumulative = 0.0;
        for (int i = 0; i < probabilities.length; i++) {
            cumulative += probabilities[i];
            if (rand <= cumulative) {
                return i;
            }
        }

        // Fallback (should not happen with valid probabilities)
        return currentState;
    }
}